---
title: "Modelo Preditivo de √ìbitos no Tr√¢nsito Brasileiro"
date: 2024-02-29

smooth-scroll: true

authors:
  - name: Jo√£o Pedro Melani Saraiva
  - name: Pedro Augusto Borges dos Santos

description: "Modelo de aprendizado de m√°quina orientado a dados relacionados √† seguran√ßa vi√°ria para o reconhecimento de padr√µes e previs√£o de √≥bitos no tr√¢nsito"

title-block-banner: true

format: 
  html:
    editor: visual
    dpi: 300
    number-sections: true
    mermaid: 
      theme: neutral

knitr: 
  opts_chunk: 
    fig.align: center

bibliography: references.bib
csl: associacao-brasileira-de-normas-tecnicas.csl
toc: true
toc-title: Sum√°rio

lang: pt
---

```{r include=FALSE}
# packages
library(tidyverse)
library(gt)
library(forecast)
library(ggcorrplot)
library(onsvplot)
library(knitr)
library(here)
library(tidymodels)
library(kableExtra)
library(fleetbr)
library(roadtrafficdeaths)
library(plotly)
library(arrow)

# op√ß√µes de display
theme_set(theme_onsv())
set.seed(123)

# load dos dados
load(here("data","tabela_total.rda"))
load(here("data","tabela_total_mensal.rda"))
load(here("data/pib_mensal.rda"))
load(here("data","tabela_condutores.rda"))
temp <- tempfile()
download.file("https://github.com/ONSV/prfdata/releases/download/v0.2.0/prf_sinistros.zip", temp)
unzip(temp, exdir = tempdir())
unlink(temp)
prf_sinistros <- open_dataset(paste(sep = "/", file.path(tempdir()), "prf_sinistros"))

# paleta
paleta = as_vector(unname(onsv_palette))

# supress√£o dos warnings
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Introdu√ß√£o

O presente cen√°rio mundial acerca de mortes e les√µes relacionadas √† sinistros de tr√¢nsito posa s√©rios desafios √† sa√∫de p√∫blica global, e as tend√™ncias evidenciadas pelos dados atuais indicam que esta realidade deve perdurar pelo futuro pr√≥ximo [@worldhealthorganization2023]. Sendo uma das causas de mortes mais comuns no mundo, as ocorr√™ncias de sinistros de tr√¢nsito afetam principalmente pedestres, ciclistas e motociclistas, al√©m de induzir severos danos materiais, tanto em quest√£o de propriedade particular quanto p√∫blica. Isto estimula pa√≠ses a buscarem m√©todos estimativos sobre os efeitos sociais, econ√¥micos e epidemiol√≥gicos da taxa de mortes no tr√¢nsito e como se traduzem em custos e perdas na produtividade da sociedade em geral [@rodr√≠guez2020].

A seguran√ßa vi√°ria pode ser um indicador da situa√ß√£o de desenvolvimento de uma regi√£o, visto que √© uma caracter√≠stica do desempenho da mobilidade urbana. Entende-se que as mortes no tr√¢nsito dependem de diversos fatores estruturais, socioecon√¥micos e ambientais do contexto urbano [@zhong-xiang2014], o que implica que elevadas taxas de sinistros vi√°rios colaboram no diagn√≥stico de problemas da mobilidade e sa√∫de p√∫blica em geral, despertando o debate pol√≠tico sobre a regulamenta√ß√£o das normas vi√°rias e apontando a car√™ncia da sociedade em combater estes eventos.

Apesar da crescente ades√£o por itens de seguran√ßa veicular, os sinistros de tr√¢nsito permanecem como um problema de sa√∫de p√∫blica, j√° que fazem parte de um agravo que repercute por toda a sociedade [@andrade2019], sendo a d√©cima segunda maior causa de √≥bitos em todas as faixas et√°rias e a principal entre indiv√≠duos de 5 a 29 anos [@worldhealthorganization2023]. Como previsto por modelos estat√≠sticos pr√©vios √† 2020 [@blumenberg2018], o Brasil apresentou baixo desempenho em cumprir a meta estabelecida pela Primeira D√©cada de A√ß√µes pela Seguran√ßa no Tr√¢nsito. Neste cen√°rio, o Plano Nacional de Redu√ß√£o de Mortes e Les√µes no Tr√¢nsito (PNATRANS) foi desenvolvido para guiar as a√ß√µes pela mobilidade segura nacional durante o per√≠odo da Segunda D√©cada de A√ß√£o pela Seguran√ßa no Tr√¢nsito [@minist√©riodostransporte2018], na inten√ß√£o de aprimorar o desempenho da seguran√ßa vi√°ria em rela√ß√£o a d√©cada passada, se alinhando aos Objetivos de Desenvolvimento Sustent√°vel estabelecidos pela Agenda 2030 da Organiza√ß√£o das Na√ß√µes Unidas (ONU). Para atingir tais metas, o Art. 3¬∫ da Resolu√ß√£o Contran N¬∫ 1004, de 21 de dezembro de 2023, relata que o PNATRANS se apoia em seis principais pilares [@conselhonacionaldetr√¢nsito2023]:

-   Gest√£o da Seguran√ßa no Tr√¢nsito;

-   Vias Seguras;

-   Seguran√ßa Veicular;

-   Educa√ß√£o para o Tr√¢nsito;

-   Vigil√¢ncia, Promo√ß√£o da Sa√∫de e Atendimento √†s V√≠timas no Tr√¢nsito e;

-   Normaliza√ß√£o e Fiscaliza√ß√£o.

Em rela√ß√£o √† Resolu√ß√£o Contran N¬∞ 870, de 13 de setembro de 2021 [@conselhonacionaldetr√¢nsito2018], a N¬∞ 1004 ratifica o quinto pilar, expandindo a vis√£o de atendimento as v√≠timas no tr√¢nsito. A resolu√ß√£o mais recente ainda adiciona ao PNATRANS os princ√≠pios e diretrizes que constituem um sistema seguro de mobilidade, aprofundando os conceitos de iniciativas, a√ß√µes e produtos promovidos pelos org√£os do Sistema Nacional de Tr√¢nsito para cada pilar.

A busca pela fundamenta√ß√£o t√©cnica para a proposi√ß√£o de pol√≠ticas p√∫blicas a respeito da mobilidade segura fomenta o estudo de diversas categorias de modelos preditivos para a sinistralidade no tr√¢nsito, tanto para estimar o n√∫mero de ocorr√™ncias quanto para avaliar a influ√™ncia das vari√°veis consideradas sobre a ocorr√™ncia de sinistros fatais. Em geral, a literatura pertinente apresenta diversos meios distintos para alcan√ßar estes modelos de melhor ajuste: Modelos lineares multivariados foram ajustados para extrair tend√™ncias sobre os crit√©rios aferidos [@blumenberg2018; @cai2015], assim como modelos preditivos baseados em cadeia de Markov [@seneta1996; @jin2020]. Outras abordagens utilizam t√©cnicas de an√°lise de s√©ries temporais, utilizando m√©todos autoregressivos como o ARIMA - Modelo Auto-Regressivo Integrado de M√©dias M√≥veis [@al-ghamdi1995] e redes neurais artificiais [@jafari2015].

O c√≥digo-fonte do trabalho todo est√° abertamente disponibilizado para acesso como reposit√≥rio no [perfil do GitHub](https://github.com/ONSV) do Observat√≥rio Nacional de Seguran√ßa Vi√°ria.

## Objetivos

Considerando o presente cen√°rio, este estudo tem como objetivo elaborar um modelo de aprendizado de m√°quina para a previs√£o de mortes no tr√¢nsito em √¢mbito nacional no Brasil, investigando dados socioecon√¥micos e estruturais com o prop√≥sito de explorar diversos tipos de tratamentos e an√°lises estat√≠sticas para criar perspectivas futuras a cerca do cen√°rio brasileiro da seguran√ßa vi√°ria. Posto isso, o projeto tamb√©m visa avaliar a qualidade de cada tipo de modelo experimentado em expressar o fen√¥meno real dos √≥bitos no tr√¢nsito, assim como elucidar a influ√™ncia e relev√¢ncia de cada vari√°vel considerada na constru√ß√£o do modelo preditivo criado com a incid√™ncia destes eventos.

## Metodologia

### Coleta de dados

A coleta de dados foi efetuada considerando as principais vari√°veis teoricamente relacionadas √† mortalidade no tr√¢nsito, e tamb√©m considerando os dados dispon√≠veis para o p√∫blico, amparando a escolha de cada grandeza na literatura previamente revisada. Estes dados s√£o reunidos e pr√©-processados para a forma√ß√£o de conjuntos de dados espec√≠ficos para cada m√©todo de modelagem, variando com a resolu√ß√£o temporal de cada abordagem (anual, trimestral e mensal).

Dito isto, investigam-se diversas bases a fim de compilar estas informa√ß√µes e extrair dados para uma an√°lise preliminar, anterior a modelagem. Entre as fontes contempladas est√£o:

-   PIB mensal, fornecido pelo Sistema Gerenciador de S√©ries Temporais do Banco Central [@bancocentraldobrasil2023], mensurado em d√≥lares;

-   Popula√ß√£o nacional residente, fornecida pelo sistema DataSUS do Minist√©rio da Sa√∫de [@minist√©riodasa√∫de2023b], obtida pelo sistema TABNET;

-   Sinistros em rodovias federais, fornecidos pelo portal de dados abertos da Pol√≠cia Rodovi√°ria Federal [@pol√≠ciarodovi√°riafederal2023];

-   Condutores habilitados, fornecidos pelo portal de estat√≠sticas da Secretaria Nacional de Tr√¢nsito (Senatran), provenientes do Registro Nacional de Condutores Habiltados (RENACH) [@minist√©riodostransporte2023];

-   Frota veicular, fornecida pelo portal de estat√≠sticas da Senatran, provenientes Registro Nacional de Ve√≠culos Automotores (RENAVAM) [@minist√©riodostransportes2023];

-   √ìbitos em sinistros de tr√¢nsito, fornecidos pelo Sistema de Informa√ß√£o de Mortalidade (SIM) do DataSUS [@minist√©riodasa√∫de2023a], obtidos com aux√≠lio da biblioteca [`microdatasus`](https://github.com/rfsaldanha/microdatasus) [@microdatasus] da linguagem de programa√ß√£o *R*.

Vale ressaltar que nem todos os dados est√£o dispon√≠veis em todas as unidades de tempo estudadas, por isso n√£o foram inclusas no processo de cria√ß√£o de certos modelos. As bases de condutores habilitados e popula√ß√£o residente, por exemplo, s√£o unicamente anuais, impossibilitando sua utiliza√ß√£o no modo trimestral e mensal.

### Modelos

#### Escalas de tempo

Em raz√£o da baixa disponibilidade de dados, os modelos confeccionados em geral contemplam uma janela de tempo de 2011 at√© a atualidade (2022), sendo as principais unidades de tempo estudadas a anual, a trimestral e a mensal. Ao criar modelos de s√©rie temporal, deve-se notar que a abund√¢ncia de dados a serem modelados tem uma rela√ß√£o direta com a capacidade do modelo em quest√£o de aprender e conseguir express√°-los futuramente, impactando no seu desempenho.

Modelos treinados em √¢mbito mensal conseguem emitir previs√µes todo m√™s, por√©m perdem precis√£o quanto mais adiante realizam previs√µes, enquanto modelos anuais podem predizer com alto desempenho os valores de anos posteriores, mas n√£o s√£o capazes de prever meses ou trimestres. Assim, estas diversas abordagens s√£o testadas a fim de comparar os desempenhos e utilidades de cada m√©todo.

#### An√°lise de S√©rie Temporal x An√°lise Determin√≠stica

√â importante ressaltar que h√° mais de uma maneira de se entender as rela√ß√µes entre os dados e, portanto, mais de uma maneira de interpret√°-los em quest√£o do processo de modelagem estat√≠stica do problema em m√£os. Neste sentido, as metodologias de an√°lise propostas a partir da observa√ß√£o dos dados dispon√≠veis implicam duas poss√≠veis linhas de racioc√≠nio no que se diz a an√°lise estat√≠stica: a an√°lise de s√©rie temporal e a an√°lise de regress√£o ou determin√≠stica.

A an√°lise de s√©rie temporal se apoia no conceito de s√©ries temporais, sendo um conjunto de dados de alguma grandeza ordenada em sequ√™ncia cronol√≥gica, para criar um modelo generalista visando prever as observa√ß√µes futuras baseado nas ocorr√™ncias passadas. Este tipo de modelagem assume que o que ocorre no momento atual, neste caso √≥bitos no tr√¢nsito, dependeria, ou possui rela√ß√£o, com o que ocorreu anteriormente. O modelo tamb√©m leva em considera√ß√£o o comportamento ao longo do tempo, como sazonalidade, tend√™ncia e heteroscedasticidade, e √© altamente dependente da *autocorrela√ß√£o*.

J√° a an√°lise de regress√£o tem como base a cria√ß√£o de um modelo de vari√°veis *preditadas* (ou dependentes) que dependem de vari√°veis *preditivas* ou *preditoras* (independentes), criando uma fun√ß√£o generalista que expressa a rela√ß√£o destas categorias de vari√°veis entre si. Diferentemente da an√°lise temporal, a regress√£o **independe da sequ√™ncia cronol√≥gica dos fatos**, mas √© diretamente afetada pela correla√ß√£o das vari√°veis independentes com a vari√°vel dependente que se deseja prever.

√Ä vista disso, o processo de modelagem pretende essencialmente englobar estas duas principais metodologias de an√°lise de dados, criando modelos de ambas as categorias. Conforme o embasamento te√≥rico acerca da seguran√ßa vi√°ria, estas modelagens s√£o poss√≠veis pelo fato de que o fen√¥meno das mortes no tr√¢nsito possuem tanto uma correla√ß√£o expressiva com vari√°veis externas, quanto dados temporais bem ordenados.

#### Configura√ß√µes

Modelos estat√≠sticos e de aprendizado de m√°quina constituem um grandioso conjunto de ferramentas e m√©todos matem√°ticos e computacionais para expressar fen√¥menos naturais por meio de fun√ß√µes e algoritmos. Visando expressar as din√¢micas dos √≥bitos ocasionados pelo transporte, o primeiro m√©todo escolhido por sua simplicidade e versatilidade √© a regress√£o linear, norteada pelo conceito de correla√ß√µes lineares entre diferentes grandezas num√©ricas.

Como discutido em @james2021, a regress√£o linear simples se enquadra como um m√©todo estat√≠stico e de aprendizado de m√°quina que se baseia na rela√ß√£o de uma vari√°vel dependente quantitativa $Y$ em fun√ß√£o de uma vari√°vel independente quantitativa $X$, com $\epsilon$ representando uma vari√°vel aleat√≥ria sobre o erro associado √† estimativa, demonstrando a rela√ß√£o matem√°tica linear entre as grandezas:

$$ Y = \beta_0 + \beta_1X + \epsilon $$

Desta forma, pode-se prever uma imagem de $Y$ ao se injetar um valor em $X$ na equa√ß√£o, dado que estas vari√°veis tenham uma correla√ß√£o linear significativa e que os ditos *coeficientes* ou *par√¢metros* $\beta_0$ e $\beta_1$ sejam estimados para este modelo. No contexto deste projeto, o objetivo √© estimar um modelo capaz de predizer as mortes em rela√ß√£o a mais de uma vari√°vel independente, tratando-se ent√£o de uma regress√£o linear m√∫ltipla:

$$ Y_i = \beta_0 + \beta_1X_1 + \beta_2X_2 + ... + \beta_nX_n + \epsilon $$

Neste estudo, esta t√©cnica de regress√£o √© amplamente utilizada em todas as resolu√ß√µes temporais em raz√£o de sua facilidade de explica√ß√£o e pelas altas correla√ß√µes lineares entre as vari√°veis. Estas correla√ß√µes estat√≠sticas s√£o expressas em √≠ndices num√©ricos pelas t√©cnicas de correla√ß√£o linear (de Pearson) e a correla√ß√£o de Spearman, como diz a @fig-ycorr. Sendo assim, ser√£o apresentados os modelo lineares anual, trimestral e mensal confeccionados com este m√©todo.

Adiante, √© esperado que alguns tipos de modelos necessitem de uma quantidade maior de dados dispon√≠veis para obterem resultados significantes. Modelos de s√©rie temporal possuem apenas uma vari√°vel, e necessitam de um conjunto extenso e "limpo" de observa√ß√µes para serem adequadamente ajustados, enquanto modelos regressivos mais complexos, como o Random Forest, s√£o propensos a sobreajuste se n√£o treinados e testados devidamente, algo que √© representa uma dificuldade em conjuntos de dados reduzidos.

A base de dados extra√≠da com maior n√∫mero de observa√ß√µes foi a base em resolu√ß√£o mensal, ent√£o os modelos de s√©rie temporal SARIMA e Suaviza√ß√£o Exponencial assim como o modelo regressor Random Forest foram efetuados apenas no contexto de meses, como indica a @tbl-modelos. Deste modo, ap√≥s a regress√£o linear anual, trimestral e mensal, o modelo Random Forest mensal foi concebido utilizando o mesmo intervalo de dados e vari√°veis:

```{r}
#| echo: false
#| label: tbl-modelos
#| tbl-cap: Tabela de escala temporal para cada modelo

data.frame(
  modelo = c("Regress√£o Linear", "Random Forest", "SARIMA", "Suaviza√ß√£o Exponencial"),
  anual = c(T, F, F, F),
  trimestral = c(T, F, F, F),
  mensal = c(T, T, T, T)
) |> 
  rename_with(str_to_title) |> 
  gt() |> 
  tab_options(
    column_labels.background.color = onsv_palette$blue,
    column_labels.font.weight = "bold"
  ) |>
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title()) |> 
  sub_values(values = T, replacement = "\u2713") |> 
  sub_values(values = F, replacement = "\u2717")
```

Conforme @james2021, o Random Forest √© um m√©todo da fam√≠lia de t√©cnicas conhecidas como √°rvores de decis√£o que se baseiam em algoritmos que segregam os dados em estratos ou *ramos*, separando os dados conforme regras de decis√£o previamente estabelecidas pelo m√©todo. Assim, estas √°rvores "crescem" com base na necessidade do algoritmo em otimizar o processo de divis√£o dos dados em conjunto menores para melhor express√°-los. O resultado deste algoritmo √© uma fun√ß√£o estat√≠stica que ir√° retornar um valor previsto com base nas regras de decis√µes impostas em cada vari√°vel preditiva.

```{mermaid}
%%| echo: false
%%| label: fig-diagram
%%| fig-cap: Diagrama demonstrativo do algoritmo de √Årvore de Decis√µes

flowchart TD
    1[N√≥ Inicial] --> 2(N√≥ de decis√£o)
    1 --> 3(N√≥ de decis√£o)
    3 --> 4(N√≥ de decis√£o)
    4 --> f5[N√≥ final]
    4 --> f6[N√≥ final]
    3 --> f3[N√≥ final]
    2 --> f1[N√≥ final]
    2 --> f2[N√≥ final]
```

O *Bagged Trees* √© uma evolu√ß√£o da √°rvore de decis√µes convencional, onde diversas √°rvores s√£o constru√≠das simultaneamente com diversos conjuntos de reamostragem aleat√≥ria ajustados paralelamente (t√©cnica de *bagging*), sendo a m√©dia do resultado de todas as √°rvores o resultado final da predi√ß√£o. O *Random Forest* √© um algoritmo que vai al√©m do *Bagged Trees*: al√©m da cria√ß√£o de m√∫ltiplas √°rvores simultaneamente, ele tamb√©m reamostra aleatoriamente as vari√°veis preditivas, selecionando conjuntos diferentes de vari√°veis para cada √°rvore. Isto serve para *descorrelacionar* estes atributos, j√° que altas correla√ß√µes entre preditivas podem enviesar o modelo final, mostrando que o Random Forest √© um algoritmo que pratica sele√ß√£o de atributos internamente.

Diversas t√©cnicas de aprendizado de m√°quina requerem valores pr√©-estabelecidos de hiperpar√¢metros para o treinamento. Neste caso, este tipo de modelo requer valores iniciais para o n√∫mero de √°rvores que se deseja treinar (par√¢metro `trees`) e o n√∫mero de atributos que se deseja reamostrar para cada √°rvore (par√¢metros `mtry`). Estes valores foram arbitrariamente escolhidos como 5000 e 5 respectivamente neste estudo, mas outra poss√≠vel abordagem seria a otimiza√ß√£o de hiperpar√¢metros, utilizando t√©cnicas como *grid search*.

Em seguida, o estudo √© dirigido √† an√°lise de s√©rie temporal, iniciando pelo modelo SARIMA (**S**easonal **A**uto**r**egressive **I**ntegrated **M**oving **A**verage\*). Como relatado em @shumway2017, este √© um m√©todo da fam√≠lia ARMA, mais especificamente uma altera√ß√£o do m√©todo ARIMA, conhecido por reduzir ou remover completamente a componente sazonal de uma s√©rie temporal univariada. O modelo ARIMA possui tr√™s par√¢metros que espelham as componentes no seu nome: $p$ para a autoregress√£o (AR), $d$ para diferencia√ß√£o (I) e $q$ para m√©dia m√≥vel (MA), criando o algoritmo $Arima(p, d, q)$.

A autoregress√£o √© simplesmente uma varia√ß√£o da regress√£o linear que utiliza de valores anteriores √† observa√ß√£o presente como vari√°veis preditivas inv√©s de outra grandeza, construindo um modelo univariado que gera previs√µes baseadas em valores pr√©vios. A diferencia√ß√£o, como citada no par√°grafo anterior, visa remover a sazonalidade, enquanto a componente de m√©dia m√≥vel t√™m o objetivo de atualizar a predi√ß√£o conforme a tend√™ncia da m√©dia. A altera√ß√£o do modelo SARIMA em rela√ß√£o ao √∫ltimo seria a adi√ß√£o de tr√™s novos par√¢metros para gerar um ARIMA espec√≠fico para a componente sazonal da s√©rie temporal, assim como um quarto componente $m$ para a periodicidade, tornando a f√≥rmula $Sarima(p,d,q)(P,D,Q)m$.

O √∫ltimo m√©todo utilizado foi a Suaviza√ß√£o Exponencial de Holt-Winters, ou Suaviza√ß√£o Exponencial Tripla. Este m√©todo √© basicamente uma aplica√ß√£o de filtragem de sinais, visando aproximar uma fun√ß√£o matem√°tica generalista sobre uma s√©rie ruidosa para melhor interpretar seu comportamento. Este *alisamento* da s√©rie resulta em um modelo simples, mas que pode ser t√£o eficaz em prever novas observa√ß√µes quanto um modelo ARMA, dependendo da sazonalidade do conjunto de dados.

## Resultados

### An√°lise Explorat√≥ria de Dados

Os conjuntos de dados extra√≠dos e pr√©-processados em fun√ß√£o das unidades de tempo denunciam os comportamentos de cada atributo em rela√ß√£o a passagem dos anos, trimestres e meses. Em destaque, os √≥bitos servem como um dos principais indicadores da qualidade e dissemina√ß√£o dos sistemas de seguran√ßa vi√°ria do pa√≠s, mostrando a evolu√ß√£o das mortes ao longo do tempo:

::: panel-tabset
## Anual

```{r}
#| echo: false
#| fig-cap: √ìbitos anuais
#| label: fig-ymortes

rtdeaths |> 
  summarise(.by = ano_ocorrencia, obitos = n()) |> 
  drop_na() |> 
  plot_ly(x = ~ano_ocorrencia, y = ~obitos, 
          type = "scatter", 
          mode = "lines",
          line = list(color = onsv_palette$blue),
          text = ~paste("V√≠timas:", obitos, "<br>Ano:", ano_ocorrencia),
          hoverinfo = "text") |> 
  layout(yaxis = list(exponentformat = "none",
                      title = "√ìbitos"),
         xaxis = list(title = "Data"),
         separators = ",.")
```

## Trimestral

```{r}
#| echo: false
#| fig-cap: √ìbitos trimestrais
#| label: fig-tmortes

rtdeaths |> 
  arrange(data_ocorrencia) |> 
  mutate(trimestre = quarter(data_ocorrencia, type = "date_last"), 
         .before = 1) |> 
  summarise(.by = trimestre, obitos = n()) |> 
  drop_na() |> 
  plot_ly(x = ~trimestre, y = ~obitos,
          type = "scatter",
          mode = "lines",
          line = list(color = onsv_palette$blue),
          text = ~paste("V√≠timas:", obitos, "<br>Trimestre:", trimestre),
          hoverinfo = "text") |> 
  layout(yaxis = list(exponentformat = "none",
                      title = "√ìbitos"),
         xaxis = list(title = "Data"),
         separators = ",.")
```

## Mensal

```{r}
#| echo: false
#| fig-cap: √ìbitos mensais
#| label: fig-mmortes

rtdeaths |> 
  arrange(data_ocorrencia) |> 
  mutate(data = ym(paste0(ano_ocorrencia,"-",month(data_ocorrencia))),
         .before = 1) |> 
  summarise(.by = data, obitos = n()) |> 
  drop_na() |>
  plot_ly(x = ~data, y = ~obitos,
          type = "scatter",
          mode = "lines",
          line = list(color = onsv_palette$blue),
          text = ~paste("V√≠timas:", obitos, "<br>M√™s:", data),
          hoverinfo = "text") |> 
  layout(yaxis = list(exponentformat = "none",
                      title = "√ìbitos"),
         xaxis = list(title = "Data"),
         separators = ",.")
```
:::

Os gr√°ficos de √≥bitos no tr√¢nsito apresentam uma tend√™ncia de incremento das v√≠timas fatais nos √∫ltimos tr√™s anos. O ano de 2019 atingiu a menor quantidade de √≥bitos relacionadas ao tr√¢nsito nos √∫ltimos 10 anos, quando em 2020 a t√™ndencia tornou a crescer. No ano de 2021 houveram 33.813 v√≠timas fatais, aproximadamente 2000 a mais que em 2019. Em 2022, esse tend√™ncia foi levemente atenuada, mantendo um n√∫mero pr√≥ximo de √≥bitos em rela√ß√£o ao ano anterior.

Assim sendo, os demais atributos do conjunto de dados podem ser visualizados em fun√ß√£o do tempo, como foi feito para o caso da vari√°vel preditada, com o intuito de destacar cada vari√°vel preditiva ao longo dos per√≠odos dispon√≠veis:

::: panel-tabset
## Frota veicular (RENAVAM)

::: panel-tabset
## Anual

```{r}
#| echo: false
#| fig-cap: Frota anual
#| label: fig-yfrota

plot_frota_anual <- fleetbr |>
  filter(mes == 7) |> 
  pivot_wider(values_from = frota, names_from = modal) |> 
  mutate(
    automovel = AUTOMOVEL + CAMINHONETE + CAMIONETA + UTILITARIO,
    motocicleta = MOTOCICLETA + CICLOMOTOR + MOTONETA,
    total = TOTAL
  ) |> 
  summarise(
    .by = ano,
    automovel = sum(automovel),
    motocicleta = sum(motocicleta),
    veiculos_total = sum(total)
  ) |> 
  rename(
    "Autom√≥veis" = automovel,
    "Motocicletas" = motocicleta,
    "Ve√≠culos totais" = veiculos_total
  ) |> 
  pivot_longer(-ano) |> 
  ggplot(aes(ano, value, color = name)) +
    geom_line() +
    geom_point(aes(text = paste("Frota:", value)), size = 0.5) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) + 
    scale_x_continuous(n.breaks = 10) +
    labs(x = "Data", y = "Frota") +
    scale_color_manual(values = paleta)

ggplotly(plot_frota_anual, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")),
         yaxis = list(title = list(standoff = 5)))
```

## Trimestral

```{r}
#| echo: false
#| fig-cap: Frota trimestral
#| label: fig-tfrota

plot_frota_tri <- fleetbr |> 
  pivot_wider(names_from = modal, values_from = frota) |> 
  mutate(
    data = ym(paste0(ano,"-",mes)),
    automovel = AUTOMOVEL + CAMINHONETE + CAMIONETA + UTILITARIO,
    motocicleta = MOTOCICLETA + CICLOMOTOR + MOTONETA
  ) |> 
  rename(total = TOTAL) |> 
  summarise(
    .by = data,
    veiculos = sum(total),
    automovel = sum(automovel),
    motocicleta = sum(motocicleta)
  ) |> 
  mutate(data = quarter(data, type = "date_last"), 
         .before = 1) |> 
  summarise(.by = data,
            across(everything(), last)) |>
  rename(
    "Autom√≥veis" = automovel,
    "Motocicletas" = motocicleta,
    "Ve√≠culos totais" = veiculos
  ) |> 
  pivot_longer(-data) |> 
  ggplot(aes(data, value, color = name)) + 
    geom_line() +
    geom_point(aes(text = paste("Frota:", value)), size = 0.5) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years") +
    labs(x = "Data", y = "Frota") +
    scale_color_manual(values = paleta)

ggplotly(plot_frota_tri, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")),
         yaxis = list(title = list(standoff = 5)))
```

## Mensal

```{r}
#| echo: false
#| fig-cap: Frota mensal
#| label: fig-mfrota

plot_frota_mensal <- fleetbr |> 
  pivot_wider(names_from = modal, values_from = frota) |> 
  mutate(
    data = ym(paste0(ano,"-",mes)),
    automovel = AUTOMOVEL + CAMINHONETE + CAMIONETA + UTILITARIO,
    motocicleta = MOTOCICLETA + CICLOMOTOR + MOTONETA
  ) |> 
  rename(total = TOTAL) |> 
  summarise(
    .by = data,
    veiculos = sum(total),
    automovel = sum(automovel),
    motocicleta = sum(motocicleta)
  ) |> 
  rename(
    "Autom√≥veis" = automovel,
    "Motocicletas" = motocicleta,
    "Ve√≠culos totais" = veiculos
  ) |> 
  pivot_longer(-data) |> 
  ggplot(aes(data, value, color = name)) +
    geom_line() + 
    geom_point(aes(text = paste("Frota:", value)), size = 0.5) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years") +
    labs(x = "Data", y = "Frota") +
    scale_color_manual(values = paleta)

ggplotly(plot_frota_mensal, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")),
         yaxis = list(title = list(standoff = 5)))
```
:::

## PIB (IBGE, BCB)

::: panel-tabset
## Anual

```{r}
#| echo: false
#| fig-cap: PIB anual
#| label: fig-ypib

plot_pib_anual <- pib_mensal |> 
  summarise(
    .by = ano, 
    pib = sum(pib)
  ) |> 
  filter(ano > 2010) |> 
  ggplot(aes(ano, pib)) +
    geom_line(color = onsv_palette$blue) +
    geom_point(aes(text = paste("PIB:",pib,"Mi US$")), color = onsv_palette$blue, size = 0.5) +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    labs(x = "Data", y = "PIB (Mi US$)")

ggplotly(plot_pib_anual, tooltip = "text") |> 
  layout(yaxis = list(title = list(standoff = 5)))
```

## Trimestral

```{r}
#| echo: false
#| fig-cap: PIB trimestral
#| label: fig-tpib

plot_pib_tri <- pib_mensal |> 
  mutate(data = quarter(ym(paste0(ano,"-",mes)), type = "date_last")) |> 
  summarise(.by = data, pib = sum(pib)) |> 
  filter(year(data) > 2010) |> 
  ggplot(aes(data, pib)) +
    geom_line(color = onsv_palette$blue) +
    geom_point(aes(text = paste("PIB:",pib,"Mi US$")), color = onsv_palette$blue, size = 0.5) +
    scale_x_date(date_breaks = "2 years") +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    labs(x = "Data", y = "PIB (Mi US$)")

ggplotly(plot_pib_tri, tooltip = "text") |> 
  layout(yaxis = list(title = list(standoff = 5)))
```

## Mensal

```{r}
#| echo: false
#| fig-cap: PIB mensal
#| label: fig-mpib

plot_pib_mensal <- pib_mensal |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  summarise(.by = data, pib = sum(pib)) |>
  filter(year(data) > 2010) |> 
  ggplot(aes(data, pib)) +
    geom_line(color = onsv_palette$blue) +
    geom_point(aes(text = paste("PIB:",pib,"Mi US$")), color = onsv_palette$blue, size = 0.5) +
    scale_x_date(date_breaks = "2 years") +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    labs(x = "Data", y = "PIB (Mi US$)")

ggplotly(plot_pib_mensal, tooltip = "text") |> 
  layout(yaxis = list(title = list(standoff = 5)))
```
:::

## Popula√ß√£o

```{r}
#| echo: false
#| fig-cap: Popula√ß√£o
#| label: fig-popul

plot_populacao <- df_total |> 
  select(populacao, ano) |> 
  drop_na() |> 
  filter(ano > 2010) |> 
  ggplot(aes(ano, populacao)) +
    geom_line(color = onsv_palette$blue) +
    geom_point(aes(text = paste("Popula√ß√£o:", populacao)), color = onsv_palette$blue, size = 0.5) +
    scale_x_continuous(breaks = seq(2011, 2021, 1)) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    labs(x = "Data", y = "Popula√ß√£o")

ggplotly(plot_populacao, tooltip = "text") |> 
  layout(yaxis = list(title = list(standoff = 5)))
```

## Sinistros em rodovias federais (PRF)

::: panel-tabset
## Anual

```{r}
#| echo: false
#| fig-cap: Sinistros anuais
#| label: fig-yprf

df_prf_plot <- prf_sinistros |> 
  mutate(
    mes = month(data_inversa),
    acidentes_fatais = if_else(
      classificacao_acidente == "Com V√≠timas Fatais",
      1, 0, missing = 0
    )
  ) |> 
  summarise(
    .by = c(mes, ano, uf),
    acidentes = n(),
    acidentes_fatais = sum(acidentes_fatais),
    feridos = sum(feridos),
    mortes = sum(mortos)
  ) |> 
  arrange(mes, ano) |> 
  collect()

plot_prf_anual <- df_prf_plot |> 
  summarise(.by = ano, across(.fns = sum, acidentes:mortes)) |> 
  filter(ano > 2010) |> 
  rename(
    "Acidentes" = acidentes,
    "Acidentes fatais" = acidentes_fatais,
    "Feridos" = feridos,
    "Mortos" = mortes
  ) |> 
  pivot_longer(-ano) |> 
  ggplot(aes(ano, value, color = name)) +
    geom_line() +
    geom_point(aes(text = paste0(name,": ", value)), size = 0.5) +
    scale_x_continuous(breaks = seq(2011, 2023, 1)) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    scale_color_manual(values = paleta) +
    labs(x = "Data", y = NULL)

ggplotly(plot_prf_anual, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```

## Trimestral

```{r}
#| echo: false
#| fig-cap: Sinistros trimestrais 
#| label: fig-tprf

plot_prf_tri <- df_prf_plot |> 
  mutate(data = quarter(ym(paste0(ano,"-",mes)), type = "date_last")) |> 
  summarise(.by = data, across(.fns = sum, acidentes:mortes)) |> 
  filter(year(data) > 2010) |> 
  rename(
    "Acidentes" = acidentes,
    "Acidentes fatais" = acidentes_fatais,
    "Feridos" = feridos,
    "Mortos" = mortes
  ) |> 
  pivot_longer(-data) |> 
  ggplot(aes(data, value, color = name)) +
    geom_line() +
    geom_point(aes(text = paste0(name,": ", value)), size = 0.5) +
    scale_x_date(date_breaks = "2 years") +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    scale_color_manual(values = paleta) +
    labs(x = "Data", y = NULL)

ggplotly(plot_prf_tri, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```

## Mensal

```{r}
#| echo: false
#| fig-cap: Sinistros mensais
#| label: fig-mprf

plot_prf_mensal <- df_prf_plot |> 
  mutate(data = ym(paste0(ano,"-",mes))) |> 
  summarise(.by = data, across(.fns = sum, acidentes:mortes)) |> 
  filter(year(data) > 2010) |> 
  rename(
    "Acidentes" = acidentes,
    "Acidentes fatais" = acidentes_fatais,
    "Feridos" = feridos,
    "Mortos" = mortes
  ) |> 
  pivot_longer(-data) |> 
  ggplot(aes(data, value, color = name)) +
    geom_line() +
    geom_point(aes(text = paste0(name,": ", value)), size = 0.5) +
    scale_x_date(date_breaks = "2 years") +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    scale_color_manual(values = paleta) +
    labs(x = "Data", y = NULL)

ggplotly(plot_prf_mensal, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```
:::

## Condutores habilitados (RENACH)

```{r}
#| echo: false
#| fig-cap: Condutores habilitados
#| label: fig-condutores

plot_condutores <- tabela_condutores |> 
  ggplot(aes(ano, condutores)) +
    geom_line(color = onsv_palette$blue) +
    geom_point(aes(text = paste("Condutores:",condutores)), color = onsv_palette$blue, size = 0.5) +
    scale_x_continuous(breaks = seq(2011, 2023, 1)) +
    scale_y_continuous(labels = label_comma(big.mark = ".", decimal.mark = ",")) +
    labs(x = "Data", y = "Condutores")

ggplotly(plot_condutores, tooltip = "text") |> 
  layout(yaxis = list(title = list(standoff = 5)))
```
:::

Observa-se uma diferen√ßa entre os comportamentos de cada atributo ao longo do tempo. Vari√°veis convencionalmente cumulativas como a frota, a popula√ß√£o e o n√∫mero de condutores habilitados disp√µe de um crescimento aproximadamente linear por todo o per√≠odo de estudo. Todavia, detecta-se que a contagem da popula√ß√£o se comportou de forma inesperada em alguns anos. Isso pode representar a diferen√ßa entre a popula√ß√£o censit√°ria e a popula√ß√£o estimada pelo IBGE.

Os dados de rodovias federais flutuam de forma an√°loga aos √≥bitos no tr√¢nsito, agindo como refer√™ncia do desempenho da seguran√ßa vi√°ria em n√≠vel nacional de determinado per√≠odo, com uma sazonalidade pronunciada. Estes dados tamb√©m mostram claramente como os √≥bitos s√£o eventos incomuns em compara√ß√£o com a quantidade de sinistros totais observados. Por√©m, enquanto a quantidade de sinistros pode variar intensamente ao longo dos anos, o n√∫mero de √≥bitos permanece relativamente constante, com uma redu√ß√£o ao longo da janela analisada.

O PIB √© o atributo com o comportamento mais particular ao longo do tempo em rela√ß√£o √†s outras vari√°veis. Foi utilizado o d√≥lar americano em lugar do real brasileiro a fim de observar a oscila√ß√£o da moeda em um contexto global e revelar a contribui√ß√£o hist√≥rica da economia nacional. Modelos realizados por @blumenberg2018 e @zhong-xiang2014 utilizam do PIB como um indicador do desempenho socioecon√¥mico do pa√≠s.

### Correla√ß√£o

O sucesso da modelagem √© inteiramente dependente da intensidade e do tipo de rela√ß√£o estat√≠stica que as vari√°veis possuem entre si. Como anteriormente citado, a regress√£o linear m√∫ltipla bem ajustada infere que as preditivas possuem uma correla√ß√£o linear forte com a preditora, mas um modelo com baixo desempenho n√£o √© necessariamente uma evid√™ncia de baixa correla√ß√£o.

Grandezas que variam juntas em uma correla√ß√£o linear s√£o ditas colineares, e o fen√¥meno da colinearidade entre vari√°veis preditivas pode vir a ocasionar sobreajuste ao modelo. Por isso, √© necess√°rio avaliar as correla√ß√µes n√£o lineares, como apontam os correlogramas, a partir do m√©todo de correla√ß√£o Spearman, nas tr√™s escalas temporais:

::: panel-tabset
## Anual

```{r}
#| echo: false
#| fig-cap: Correla√ß√£o de Spearman Anual
#| label: fig-ycorr

cor_spearman_anual <- df_total |> 
  drop_na() |> 
  select(-c(quilometragem_10_bilhoes, mortos_por_pop, ano)) |> 
  rename(
    `√ìbitos` = mortes,
    Autom√≥veis = automovel,
    Motocicletas = motocicleta,
    `Ve√≠culos Totais` = veiculos_total,
    PIB = pib,
    `Popula√ß√£o` = populacao,
    Acidentes = qnt_acidentes,
    `Acidentes fatais` = qnt_acidentes_fatais,
    Feridos = qnt_feridos,
    Condutores = condutores,
    `Mortes PRF` = qnt_mortos
  ) |> 
  cor(method = "spearman")

ggcorrplot(
  cor_spearman_anual,
  lab_col = "white",
  type = "lower",
  lab = T,
  hc.order = T,
  lab_size = 3, 
  tl.srt = 60,
  tl.cex = 12, 
  legend.title = "Correla√ß√£o",
  colors = c(onsv_palette$blue, "white", onsv_palette$red)
)
```

## Trimestral

```{r}
#| echo: false
#| fig-cap: Correla√ß√£o de Spearman Trimestral
#| label: fig-tcorr

cor_spearman_trimestral <- dados_mensais |> 
  mutate(data = quarter(data, type = "date_last")) |> 
  summarise(
    .by = data,
    veiculos = last(veiculos),
    automovel = last(automovel),
    motocicleta = last(motocicleta),
    mortes = sum(mortes),
    pib = sum(pib),
    acidentes = sum(acidentes),
    acidentes_fatais = sum(acidentes_fatais),
    feridos = sum(feridos),
    mortes_prf = sum(mortes_prf)
  ) |> 
  select(-data) |> 
  rename(
    `√ìbitos` = mortes,
    Autom√≥veis = automovel,
    Motocicletas = motocicleta,
    `Ve√≠culos Totais` = veiculos,
    PIB = pib,
    Acidentes = acidentes,
    `Acidentes fatais` = acidentes_fatais,
    Feridos = feridos,
    `Mortes PRF` = mortes_prf
  ) |> 
  cor(method = "spearman")

ggcorrplot(
  cor_spearman_trimestral,
  lab_col = "white",
  type = "lower",
  lab = TRUE, 
  hc.order = T,
  lab_size = 3, 
  tl.srt = 60,
  tl.cex = 12, 
  legend.title = "Correla√ß√£o",
  colors = c(onsv_palette$blue, "white", onsv_palette$red)
)
```

## Mensal

```{r}
#| echo: false
#| fig-cap: Correla√ß√£o de Spearman Mensal
#| label: fig-mcorr

cor_spearman_mensal <-dados_mensais |> 
  select(-data) |> 
  rename(
    `√ìbitos` = mortes,
    Autom√≥veis = automovel,
    Motocicletas = motocicleta,
    `Ve√≠culos Totais` = veiculos,
    PIB = pib,
    Acidentes = acidentes,
    `Acidentes fatais` = acidentes_fatais,
    Feridos = feridos,
    `Mortes PRF` = mortes_prf
  ) |> 
  cor(method = "spearman")

ggcorrplot(
  cor_spearman_mensal,
  lab_col = "white",
  type = "lower",
  lab = TRUE, 
  hc.order = T,
  lab_size = 3, 
  tl.srt = 60,
  tl.cex = 12, 
  legend.title = "Correla√ß√£o",
  colors = c(onsv_palette$blue, "white", onsv_palette$red)
)
```
:::

Em todos os correlagramas se encontram valores significativos para praticamente todas as vari√°veis, sendo que as matrizes de ùëù-valores calculados rejeitam a hip√≥tese nula com facilidade para todos os atributos, todos os casos.

### Taxas de √≥bitos

O diagn√≥stico da seguran√ßa no tr√¢nsito de uma uma regi√£o em um determinado intervalo de tempo √© um dos principais t√≥picos no campo da mobilidade segura, visto que as vari√°veis que influenciam a sa√∫de no tr√¢nsito n√£o s√£o um consenso acad√™mico absoluto. Este fato fomenta a pesquisa e desenvolvimento de novas metodologias e indicadores espec√≠ficos para a an√°lise estat√≠stica do cen√°rio brasileiro que melhor interpretem os dados dispon√≠veis e representem o fen√¥meno real da sinistralidade de maneira veross√≠mil. @ferraz2023 disserta sobre a quest√£o da quantifica√ß√£o e qualifica√ß√£o da sinistralidade por meio da determina√ß√£o de √≠ndices utilizando das mortes, popula√ß√£o e frota como par√¢metros para estabelecer valores representativos do n√≠vel de seguran√ßa do local.

Estes √≠ndices s√£o usualmente referidos em fun√ß√£o de altas casas decimais para salientar a signific√¢ncia dos valores de cada taxa calculada. As taxas que direcionaram o presente estudo na avalia√ß√£o da sinistralidade anual foram as v√≠timas fatais por 100 mil habitantes e v√≠timas fatais por 10 mil ve√≠culos, como indicado:

```{r}
#| echo: false
#| fig-cap: Taxas de √≥bitos
#| label: fig-taxa-obitos

plot_taxas <- df_total |> 
  select(ano, veiculos_total, populacao, mortes) |> 
  drop_na() |> 
  mutate(taxa_hab = (mortes/populacao) * 100000,
         taxa_veic = (mortes/veiculos_total) * 10000) |> 
  select(ano, taxa_hab, taxa_veic) |> 
  rename(
    "√ìbitos por 100.000 hab" = taxa_hab,
    "√ìbitos por 10.000 ve√≠culos" = taxa_veic
  ) |> 
  pivot_longer(-ano) |> 
  ggplot(aes(ano, value, color = name)) +
    geom_line() +
    geom_point(aes(text = paste0(name,": ", round(value, 2)))) +
    facet_wrap(vars(name), scales = "free_y") +
    labs(y = "√çndices", x = "Data") +
    scale_color_manual(values = paleta)

ggplotly(plot_taxas, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```

As duas taxas anunciam tend√™ncias distintas a cerca da fatalidade no tr√¢nsito brasileiro. Enquanto o √≠ndice de mortes por ve√≠culos oferece uma perspectiva de estabiliza√ß√£o no n√∫mero de v√≠timas, a taxa de habitantes corrobora √† vis√£o de que as mortes est√£o inclinadas ao aumento na d√©cada atual. Deve-se levar em considera√ß√£o que esta diferen√ßa de comportamente pode resultar da evolu√ß√£o da frota veicular e da popula√ß√£o nacional em taxas distintas.

### Resultados dos modelos

A avalia√ß√£o de desempenho de cada modelo foi gerada a partir da necessidade e especifica√ß√µes de cada caso. Visualiza√ß√µes podem ser criadas para todos os modelos a fim de apresentar a proximidade das previs√µes em rela√ß√£o aos valores reais. M√©tricas de erros s√£o utilizadas para quantificar a taxa de acertos de cada modelo, notando-se que em modelos com maior disponibilidade de dados (trimestral e mensal) foi efetuada a reparti√ß√£o de amostras para treino e para teste.

A reparti√ß√£o dividiu as amostras com uma propor√ß√£o de 75% dos dados para o treinamento dos modelos, sendo o restante utilizado na valida√ß√£o das previs√µes pelo c√°lculo do Erro Quadrado M√©dio Absoluto (*Root Mean Squared Error* - RMSE), Erro M√©dio Absoluto *(Mean Squared Error* - MAE) e o ùëÖ^2^, ou coeficiente de determina√ß√£o. A t√©cnica de reparti√ß√£o de treino e teste √© consideravelmente mais simples que o m√©todo de valida√ß√£o cruzada comumente utilizado em modelos de aprendizado de m√°quina mais robustos, mas pode ser mais adequada √† *databases* menores, dado que a valida√ß√£o cruzada n√£o influenciou na performance dos modelos e foi abandonada devido ao gasto computacional desnecess√°rio. J√° no caso do modelo anual, que possui um conjunto ainda menor de dados, a reparti√ß√£o √© invi√°vel e a valida√ß√£o foi dada com o mesmo conjunto do treinamento.

#### Regress√£o Linear M√∫ltipla

A an√°lise de regress√£o linear m√∫ltipla foi a abordagem mais extensamente utilizada durante a produ√ß√£o do estudo, podendo ser dividida entre as escalas temporais anual, trimestral e mensal. Cada m√©trica e modelo s√£o extra√≠dos apresentados para avalia√ß√£o das suas performances, com os resultados segregados por unidade de tempo.

##### Anual

```{r}
#| include: false

metricas <- metric_set(rmse, mae, rsq)

dados_modelo_2023 <- list(
  drop_na(count(rename(rtdeaths, ano = ano_ocorrencia), ano, name = "mortes")),
  summarise(filter(fleetbr, modal == "TOTAL", mes == 7), 
            .by = ano, frota = sum(frota)),
  prf_sinistros |> 
    filter(classificacao_acidente == "Com V√≠timas Fatais") |> 
    count(ano, name = "acids_fatais") |> 
    collect(),
  prf_sinistros |> 
    count(ano, name = "acids") |> 
    collect(),
  tabela_condutores
) |> 
  reduce(full_join, by = "ano") |> 
  arrange(ano)

rec_anual_2023 <-
  recipe(x = drop_na(dados_modelo_2023), mortes ~ .) |> 
  remove_role(ano, old_role = "predictor") |> 
  step_normalize(all_numeric_predictors())

modelo_anual_2023 <-
  linear_reg() |> 
  set_engine("lm")
  
wflow_anual_2023 <-
  workflow() |> 
  add_model(modelo_anual_2023) |> 
  add_recipe(rec_anual_2023) |> 
  fit(drop_na(dados_modelo_2023))

pred_anual_2023 <- bind_cols(
  dados_modelo_2023,
  predict(wflow_anual_2023, dados_modelo_2023),
  predict(wflow_anual_2023, dados_modelo_2023, type = "conf_int")
)

metricas_anual <- metricas(data = pred_anual_2023, truth = mortes, estimate = .pred)
```

Para o caso da an√°lise anual, as previs√µes emitidas s√£o comparadas com as ocorr√™ncias reais, enquanto as m√©tricas s√£o baseadas no mesmo conjunto de ajuste do modelo:

::: panel-tabset
## S√©rie

```{r}
#| echo: false
#| fig-cap: Previs√£o anual para RL
#| label: fig-ypred-rl

plot_pred_anual <- pred_anual_2023 |> 
  select(ano, mortes, .pred, .pred_lower, .pred_upper) |> 
  pivot_longer(
    cols = c(.pred, mortes),
    names_to = "Tipo",
    values_to = "Mortes"
  ) |> 
  mutate(
    Tipo = if_else(Tipo == "mortes", "√ìbitos reais", "√ìbitos previstos")
  ) |> 
  filter(ano>2010) |> 
  ggplot(aes(ano, Mortes, color = Tipo)) +
    geom_ribbon(
      aes(ymax = .pred_upper, ymin = .pred_lower),
      fill = "grey",
      color = "grey",
      alpha = 0.25
    ) +
    geom_line() +
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0))), size = 0.5) +
    scale_x_continuous(breaks = seq(2011,2023,1)) +
    scale_y_continuous(labels = comma_format(big.mark = ".")) +
    scale_color_manual(values = paleta) + 
    labs(x = NULL, y = NULL)

ggplotly(plot_pred_anual, tooltip = "text")
```

## Previsto x Real

```{r}
#| echo: false
#| fig-cap: Previsto x Real anual RL
#| label: fig-yqqplot-rl

plot_qq_anual <- pred_anual_2023 |> 
  select(.pred, mortes, ano) |> 
  drop_na() |> 
  rename(Previsto = .pred, Real = mortes) |> 
  ggplot(aes(x = Real, y = Previsto)) +
  geom_point(aes(text = paste0("√ìbitos reais: ", Real, "<br>√ìbitos previstos: ", round(Previsto, 0), "<br>Data: ", ano)), color = onsv_palette$blue) +
  geom_abline(
    linewidth = 1, 
    alpha = 0.5, 
    color = onsv_palette$blue, 
    lty = "dashed"
  ) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) + 
  scale_x_continuous(labels = comma_format(big.mark = ".")) +
  coord_obs_pred()

ggplotly(plot_qq_anual, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para RL anual
#| label: tbl-ymetric-rl

metricas_anual |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

Como √© demonstrado pelo amplo intervalo de confian√ßa preditado (√°rea em cinza no gr√°fico), o fato do conjunto de dados anuais ser relativamente pequeno confere uma incerteza atribu√≠da √† essa abordagem. Para 2023, o modelo prev√™ 34.631 √≥bitos no tr√¢nsito brasileiro, uma diferen√ßa de 737 v√≠timas e um aumento de aproximadamente 2,1% em rela√ß√£o ao valor real do ano anterior (2022).

As m√©tricas RMSE e MAE s√£o melhor aplicadas de forma comparativa entre diferentes ajustes, sendo utilizados para auxiliar na sele√ß√£o de atributos para o treinamento do modelo. Foi conclu√≠do que as melhores vari√°veis para explicar as ocorr√™ncias de √≥bitos no tr√¢nsito para esta categoria de modelo foram a frota total, os acidentes totais e fatais em rodovias federais e os condutores habilitados.

Como este modelo em espec√≠fico possui maior variedade de atributos, a combina√ß√£o de diversas configura√ß√µes de preditivas foi feita manualmente para melhor filtrar as vari√°veis √∫teis. Componentes como a popula√ß√£o, o PIB e as mortes em rodovias federais foram considerados muito colineares, prejudicando a performance do modelo. Na @tbl-coefs, est√£o explicitados os melhores atributos e seus coeficientes:

```{r}
#| echo: false
#| tbl-cap: Coeficientes para modelo anual
#| label: tbl-coefs

wflow_anual_2023 |>
  tidy() |>
  mutate(
    "Vari√°vel" = c(
      "Intercepto Y",
      "Frota",
      "Acidentes fatais",
      "Acidentes",
      "Condutores"
    ),
    .before = 1
  ) |> 
  select(1, 3, 6) |> 
  rename(
    Coeficientes = estimate,
    `P-valor` = p.value
  ) |> 
  mutate(across(where(is.numeric), round, 2)) |> 
  gt() |> 
  tab_options(
    column_labels.background.color = onsv_palette$blue,
    column_labels.font.weight = "bold"
  ) |>
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title())
```

##### Trimestral

Os dados utilizados foram obtidos por meio do agrupamento trimestral dos dados mensais, sendo constitu√≠da uma base de dados espec√≠fica para o ajuste deste modelo de regress√£o. As m√©tricas e visualiza√ß√µes para avalia√ß√£o da performance foram as mesmas do modelo anual, por√©m, a partir deste, todos os pr√≥ximos modelos s√£o reamostrados em conjuntos de treino e teste para a valida√ß√£o adequada:

```{r}
#| include: false

df_frota_2023 <- fleetbr |> 
  pivot_wider(names_from = modal, values_from = frota) |> 
  mutate(
    data = ym(paste0(ano,"-",mes)),
    automovel = AUTOMOVEL + CAMINHONETE + CAMIONETA + UTILITARIO,
    motocicleta = MOTOCICLETA + CICLOMOTOR + MOTONETA
  ) |> 
  rename(total = TOTAL) |> 
  summarise(
    .by = data,
    veiculos = sum(total),
    automovel = sum(automovel),
    motocicleta = sum(motocicleta)
  )

df_mortes_2023 <- rtdeaths |> 
  mutate(mes = month(data_ocorrencia),
         ano = year(data_ocorrencia),
         data = ym(paste0(ano, "-", mes))) |> 
  count(data, name = "mortes") |> 
  drop_na()

df_pib_2023 <- pib_mensal |> 
  mutate(data = ym(paste0(ano, "-", mes))) |> 
  group_by(data) |> 
  summarise(pib)

df_prf_2023 <- prf_sinistros |> 
  collect() |> 
  mutate(
    acidentes_fatais = if_else(
      classificacao_acidente == "Com V√≠timas Fatais", 1, 0, missing = 0
    ),
    mes = month(data_inversa),
    data = ym(paste0(ano, "-", mes))
  ) |> 
  summarise(
    .by = data,
    acidentes = n(),
    acidentes_fatais = sum(acidentes_fatais),
    feridos = sum(feridos),
    mortes_prf = sum(mortos)
  ) |> 
  arrange(data)
  
dados_mensais_2023 <- 
  list(df_frota_2023, df_mortes_2023, df_pib_2023, df_prf_2023) |> 
  reduce(full_join, by = "data") |> 
  arrange(data)

df_trimestre_2023 <- dados_mensais_2023 |>
  mutate(
    trimestre = quarter(data),
    data = quarter(data, type = "date_last")
  ) |> 
  group_by(data, trimestre) |> 
  summarise(
    veiculos = last(veiculos),
    automovel = last(automovel),
    motocicleta = last(motocicleta),
    mortes = sum(mortes),
    pib = sum(pib),
    acidentes = sum(acidentes),
    acidentes_fatais = sum(acidentes_fatais),
    feridos = sum(feridos),
    mortes_prf = sum(mortes_prf)
  ) |> 
  ungroup()

splits_trimestre <- initial_split(drop_na(df_trimestre_2023), prop = 3/4)
train_trimestre <- training(splits_trimestre)
test_trimestre <- testing(splits_trimestre)

rec <- 
  recipe(df_trimestre_2023, mortes ~ .) |> 
  remove_role(c(mortes_prf, trimestre, data), old_role = "predictor") |> 
  step_normalize(all_numeric_predictors())

model <-
  linear_reg() |>
  set_engine("lm")

lm_wflow <-
  workflow() |> 
  add_model(model) |> 
  add_recipe(rec)

lm_wflow_fit <-
  lm_wflow |> 
  fit(train_trimestre)

pred_trimestre_2023 <- bind_cols(
  df_trimestre_2023,
  predict(lm_wflow_fit, df_trimestre_2023),
  predict(lm_wflow_fit, df_trimestre_2023, type = "conf_int")
)

metricas_trimestre <- bind_cols(
  test_trimestre,
  predict(lm_wflow_fit, test_trimestre)
) |> 
  metricas(truth = mortes, estimate = .pred)
```

::: panel-tabset
## S√©rie

```{r}
#| echo: false
#| fig-cap: Previs√£o trimestral para RL
#| label: fig-tpred-rl

plot_pred_tri <- pred_trimestre_2023 |> 
  select(data, trimestre, mortes, .pred_lower, .pred_upper, .pred) |> 
  filter(year(data) > 2010) |>  
  pivot_longer(cols = c(.pred, mortes),
               names_to = "Tipo",
               values_to = "Mortes") |> 
  mutate(Tipo = if_else(Tipo == "mortes", "√ìbitos reais", "√ìbitos previstos")) |> 
  ggplot(aes(data, Mortes, color = Tipo)) +
    geom_ribbon(
      aes(ymax = .pred_upper, ymin = .pred_lower),
      fill = "grey",
      color = "grey",
      alpha = 0.25
    ) +
    scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years") +
    geom_line() +
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0))), size = 0.5) +
    scale_color_manual(values = paleta) + 
    labs(x = NULL, y = NULL)

ggplotly(plot_pred_tri, tooltip = "text")
```

## Previsto x Real

```{r}
#| echo: false
#| fig-cap: Previsto x Real trimestral RL
#| label: fig-tqqplot-rl

plot_qq_tri <- pred_trimestre_2023 |> 
  select(data, .pred, mortes) |> 
  drop_na() |> 
  rename(Previsto = .pred, Real = mortes) |> 
  ggplot(aes(x = Real, y = Previsto)) +
  geom_point(aes(text = paste0("√ìbitos reais: ", Real, "<br>√ìbitos previstos: ", round(Previsto, 0), "<br>Data: ", data)), color = onsv_palette$blue) +
  geom_abline(
    linewidth = 1, 
    alpha = 0.5, 
    color = onsv_palette$blue, 
    lty = "dashed"
  ) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) + 
  scale_x_continuous(labels = comma_format(big.mark = ".")) +
  coord_obs_pred()

ggplotly(plot_qq_tri, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para RL trimestral
#| label: tbl-tmetric-rl

metricas_trimestre |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

O grafico da @fig-tpred-rl espelha visualmente a periodicidade e sazonalidade trimestral da mortalidade no tr√¢nsito, revelando a exist√™ncia de √©pocas de maior risco no tr√¢nsito em todos os anos, independente da tend√™ncia da s√©rie temporal de √≥bitos. Como esperado, a maior disponibilidade de dados resulta em altera√ß√µes positivas nas m√©tricas de erros em rela√ß√£o √† escala temporal anual.

##### Mensal

A escala mensal √© a menor unidade temporal abordada para o estudo e permite observar a sazonalidade dos sinistros:

```{r}
#| include: false

split_2023 <- initial_split(drop_na(dados_mensais_2023), prop = 0.8)

train_2023 <- training(split_2023)
test_2023 <- testing(split_2023)

rec_mensal_2023 <-
  recipe(train_2023, mortes ~ .) |> 
  remove_role(c(mortes_prf, data), old_role = "predictor") |> 
  step_normalize(all_numeric_predictors())

lm_mensal_2023 <-
  linear_reg() |> 
  set_engine("lm")

lm_wflow_mensal_2023 <-
  workflow() |> 
  add_model(lm_mensal_2023) |> 
  add_recipe(rec_mensal_2023) |> 
  fit(train_2023)

pred_mensal_2023 <-
  bind_cols(
    dados_mensais_2023,
    predict(lm_wflow_mensal_2023, dados_mensais_2023),
    predict(lm_wflow_mensal_2023, dados_mensais_2023, type = "conf_int")
  )

metricas_mensal <- metricas(pred_mensal_2023, truth = mortes, estimate = .pred)
```

::: panel-tabset
## S√©rie

```{r}
#| echo: false
#| fig-cap: Previs√£o mensal para RL
#| label: fig-mpred-rl

plot_pred_mensal <- pred_mensal_2023 |> 
  filter(year(data) > 2010) |> 
  pivot_longer(cols = c(.pred, mortes),
               names_to = "Tipo",
               values_to = "Mortes") |> 
  mutate(Tipo = if_else(Tipo == "mortes", "√ìbitos reais", "√ìbitos previstos")) |> 
  ggplot(aes(data, Mortes, color = Tipo)) +
    geom_ribbon(aes(ymax = .pred_upper, ymin = .pred_lower),
                fill = "grey", color = "grey", alpha = 0.25) +
    geom_line() +
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0))), size = 0.5) +
    scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years") +
    labs(x = NULL, y = NULL) +
    scale_color_manual(values = paleta)

ggplotly(plot_pred_mensal, tooltip = "text")
```

## Previsto x Real

```{r}
#| echo: false
#| fig-cap: Previsto x Real mensal RL
#| label: fig-mqqplot-rl

plot_qq_mensal <- pred_mensal_2023 |> 
  select(data, .pred, mortes) |> 
  drop_na() |> 
  rename(Previsto = .pred, Real = mortes) |> 
  ggplot(aes(x = Real, y = Previsto)) +
  geom_point(aes(text = paste0("√ìbitos reais: ", Real, "<br>√ìbitos previstos: ", round(Previsto, 0), "<br>Data: ", data)), color = onsv_palette$blue) +
  geom_abline(
    linewidth = 1, 
    alpha = 0.5, 
    color = onsv_palette$blue, 
    lty = "dashed"
  ) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) + 
  scale_x_continuous(labels = comma_format(big.mark = ".")) +
  coord_obs_pred()

ggplotly(plot_qq_mensal, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para RL mensal
#| label: tbl-mmetric-rl

metricas_mensal |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

Uma das caracter√≠sticas not√°veis deste modelo √© sua capacidade de descrever observa√ß√µes an√¥malas ao decorrer dos anos, onde os √≥bitos ultrapassam os intervalos de confian√ßa estipulados pelo modelo, mesmo que este apresente uma alta performance e capacidade preditiva segundo as m√©tricas.

#### Regressor Random Forest

O segundo modelo utilizado para a an√°lise de regress√£o, como anteriormente explicado, foi o Regressor Random Forest, ajustado apenas para o contexto mensal. Esta t√©cnica dispensa a sele√ß√£o de atributos manual que fora necess√°ria para o caso da regress√£o linear, j√° que possui um algoritmo seletor interno. Sendo assim, este modelo √© treinado e validado no mesmo conjunto mensal anteriormente processado:

```{r}
#| include: false

rf <- 
  rand_forest(
    mode = "regression",
    mtry = 5,
    trees = 5000
  ) |> 
  set_engine("ranger")

rf_wflow <- 
  workflow() |> 
  add_model(rf) |> 
  add_recipe(rec_mensal_2023) |>
  fit(train_2023)

rf_pred <- bind_cols(
  predict(rf_wflow, drop_na(dados_mensais_2023, veiculos)),
  drop_na(dados_mensais_2023, veiculos)
)

metricas_rf <- bind_cols(
  predict(rf_wflow, test_2023),
  test_2023
) |> 
  metricas(truth = mortes, estimate = .pred)
```

::: panel-tabset
## S√©rie

```{r}
#| echo: false
#| fig-cap: Previs√£o por RF
#| label: fig-pred-rf

plot_pred_rf <- rf_pred |> 
  pivot_longer(c(.pred, mortes), names_to = "Tipo", values_to = "Mortes") |> 
  mutate(Tipo = if_else(Tipo == "mortes", "√ìbitos reais", "√ìbitos previstos")) |> 
  ggplot(aes(data, Mortes, color = Tipo)) +
    geom_line() +
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0))), size=0.5) +
    scale_color_manual(values = paleta) +
    scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years") +
    labs(x = NULL, y = NULL)

ggplotly(plot_pred_rf, tooltip = "text")
```

## Previsto x Real

```{r}
#| echo: false
#| fig-cap: Previsto x Real para RF
#| label: fig-qqplot-rf

plot_qq_rf <- rf_pred |> 
  select(data, .pred, mortes) |> 
  drop_na() |> 
  rename(Previsto = .pred, Real = mortes) |> 
  ggplot(aes(x = Real, y = Previsto)) +
  geom_point(aes(text = paste0("√ìbitos reais: ", Real, "<br>√ìbitos previstos: ", round(Previsto, 0), "<br>Data: ", data)), color = onsv_palette$blue) +
  geom_abline(
    linewidth = 1, 
    alpha = 0.5, 
    color = onsv_palette$blue, 
    lty = "dashed"
  ) +
  scale_y_continuous(labels = comma_format(big.mark = ".")) + 
  scale_x_continuous(labels = comma_format(big.mark = ".")) +
  coord_obs_pred()

ggplotly(plot_qq_rf, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para RF
#| label: tbl-metric-rf

metricas_rf |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

O Random Forest se sobressai visualmente no gr√°fico de valores previstos sobre valores reais, visto que as previs√µes aparentam se aproximar mais √† linha de converg√™ncia em rela√ß√£o ao modelo anterior. Apesar da incapacidade do algoritmo em gerar intervalos de confian√ßa, o Random Forest raramente estima valores an√¥malos, apontando que √© menos sens√≠vel a *outliers*. Como mencionado na descri√ß√£o te√≥rica deste algoritmo, este efeito √© associado a reamostragem que o modelo faz enquanto est√° construindo as "√°rvores" pela t√©cnica *bagging*, reduzindo o enviesamento dos valores discrepantes.

#### SARIMA

```{r}
#| include: false

df_mortes <- rtdeaths |> 
  arrange(data_ocorrencia) |> 
  mutate(data = ym(paste0(ano_ocorrencia, '-', month(data_ocorrencia))),
         .before = 1) |> 
  summarise(.by = data, mortes = n()) |> 
  drop_na()

ts <- ts(df_mortes$mortes, start = c(1996, 1), end = c(2022, 12), frequency = 12)

decomposed <- decompose(ts)
```

Ap√≥s as an√°lises regressivas, a pr√≥xima abordagem est√°tistica estudada √© a an√°lise de s√©ries temporais univariadas, sobretudo iniciada pela condu√ß√£o de experimentos utilizando do m√©todo SARIMA. Entretanto, antes da modelagem propriamente dita, algumas evid√™ncias podem ser reunidas para indicar a viabilidade destes m√©todos temporais, como a decomposi√ß√£o da s√©rie temporal:

::: panel-tabset
## S√©rie Original

```{r}
#| echo: false
#| fig-cap: S√©rie temporal de √≥bitos
#| label: fig-ts

autoplot(
  ts, 
  color = onsv_palette$blue, 
  ylab = "Mortes", xlab = "Data")
```

## Tend√™ncia

```{r}
#| echo: false
#| fig-cap: Componente de tend√™ncia
#| label: fig-trend

autoplot(
  decomposed$trend,
  color = onsv_palette$blue,
  ylab = "Mortes", xlab = "Data")
```

## Sazonalidade

```{r}
#| echo: false
#| fig-cap: Componente de sazonalidade
#| label: fig-season

autoplot(
  decomposed$seasonal,
  color = onsv_palette$blue,
  ylab = "Mortes", xlab = "Data")
```

## Residual

```{r}
#| echo: false
#| fig-cap: Componente residual
#| label: fig-residual

autoplot(
  decomposed$random,
  color = onsv_palette$blue,
  ylab = "Mortes", xlab = "Data")
```
:::

A s√©rie decomposta √© observada para determinar se o comportamento da quantidade de mortes ao longo do tempo √© caracter√≠stico de uma s√©rie model√°vel pelo SARIMA. A tend√™ncia √© um forte indicativo de que h√° uma m√©dia m√≥vel neste fen√¥meno, mas a grande quantidade de res√≠duo aponta que n√£o h√° uma sazonalidade t√£o bem estabelicida e c√≠clica. Assim, outros m√©todos usados para o entendimento da sinistrilidade no tempo s√£o os gr√°ficos ACF (Fator de Autocorrela√ß√£o) e PACF (Fator de Autocorrela√ß√£o Parcial):

```{r}
#| echo: false
#| fig-cap: Gr√°ficos de autocorrela√ß√£o
#| label: fig-autocor

par(mfrow = c(1, 2))
acf(ts, main = "ACF")
pacf(ts, main = "PACF")
par(mfrow = c(1, 1))
```

Desta maneira, atenta-se que os dados possuem altas correla√ß√µes com diversos per√≠odos de atraso de forma indireta e direta. Em especial, a quantidade de √≥bitos em um certo m√™s aparenta estar profundamente relacionada ao n√∫mero de √≥bitos no mesmo m√™s no ano anterior, visto que h√° uma alta correla√ß√£o no *lag* de 12 meses para ambos os gr√°ficos.

Estas an√°lises s√£o √∫teis para a decis√£o manual de valores iniciais para os par√¢metros do SARIMA. Todavia, outra forma mais adequada e automatizada de chegar ao ajuste ideal para o modelo √© a fun√ß√£o de ajuste autom√°tico `auto.arima()` do pacote [`forecast`](https://github.com/robjhyndman/forecast) [@hyndman2008], uma implementa√ß√£o do m√©todo que busca a melhor combina√ß√£o de par√¢metros baseado nos crit√©rios de sele√ß√£o de modelo AIC (*Akaike Information Criterion*) e BIC (*Bayesian Information Criterion*).

```{r}
#| include: false

sarima <- auto.arima(
  ts,
  stationary = F,
  seasonal = T
)

sarima_pred <- cbind(fit = sarima$fitted, 
                  forecast = forecast(sarima, h = 12)$mean, 
                  mortes = sarima$x,
                  .pred_lower = forecast(sarima, h = 12)$lower,
                  .pred_upper = forecast(sarima, h = 12)$upper)
sarima_pred <- 
  data.frame(sarima_pred, data = zoo::as.Date(time(sarima_pred))) |> 
  mutate(.pred = coalesce(forecast, fit), .before = 1) |> 
  select(-c(fit, forecast))

metricas_sarima <- metricas(sarima_pred, truth = mortes, estimate = .pred)
```

::: panel-tabset
## Previs√£o

```{r}
#| echo: false
#| fig-cap: fig-pred-arima 
#| label: Previs√£o por SARIMA

plot_pred_sarima <- sarima_pred |> 
  filter(year(data) > 2010) |> 
  pivot_longer(c(.pred, mortes), names_to = "Tipo", values_to = "Mortes") |> 
  mutate(Tipo = if_else(Tipo == "mortes", 
                        "√ìbitos reais", "√ìbitos previstos")) |> 
  ggplot(aes(data, Mortes)) +
    geom_ribbon(aes(ymin = .pred_lower.80., ymax = .pred_upper.80.), fill = "grey80", alpha = 0.5) +
    geom_ribbon(aes(ymin = .pred_lower.95., ymax = .pred_upper.95.), fill = "grey90", alpha = 0.5) +
    geom_line(aes(color = Tipo)) + 
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0)), color = Tipo), size = 0.5) +
    scale_color_manual(values = paleta) +
    labs(x = NULL, y = NULL) +
    scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years")

ggplotly(plot_pred_sarima, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para SARIMA
#| label: tbl-metrics-arima

metricas_sarima |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

Por ser um modelo autoregressivo univariado, as previs√µes emitidas pelo SARIMA s√£o ruidosas, produzindo amplos intervalos de confian√ßa. Modelos dessa categoria possuem baixa longevidade visto que seu desempenho diminui conforme a dist√¢ncia da previs√£o ao conjunto original. Em compara√ß√£o a modelos determin√≠sticos, n√£o necessitam de outras vari√°veis para ter resultados e s√£o, em geral, mais simples computacionalmente.

#### Suaviza√ß√£o Exponencial

```{r}
#| include: false

ets <- HoltWinters(ts)

ets_pred <- cbind(fit = ets$fitted[, "xhat"], 
                  forecast = forecast(ets, h = 12)$mean, 
                  mortes = ets$x,
                  .pred_lower = forecast(ets, h = 12)$lower,
                  .pred_upper = forecast(ets, h = 12)$upper)
ets_pred <- 
  data.frame(ets_pred, data = zoo::as.Date(time(ets_pred))) |> 
  mutate(.pred = coalesce(forecast, fit), .before = 1) |> 
  select(-c(fit, forecast))

metricas_ets <- metricas(ets_pred, truth = mortes, estimate = .pred)
```

A Suaviza√ß√£o Exponencial Holt-Winters √© o segundo modelo de an√°lise de s√©ries temporais estudado, o qual possui uma abordagem te√≥rica distinta do anterior. Sendo um modelo de suaviza√ß√£o, este pretende aproximar uma fun√ß√£o que filtre a s√©rie temporal original e expresse o comportamento dos dados de forma simplificada.

::: panel-tabset
## Previs√£o

```{r}
#| echo: false
#| fig-cap: Previs√£o por ETS
#| label: fig-pred-ets

plot_pre_ets <- ets_pred |> 
  filter(year(data) > 2010) |> 
  pivot_longer(c(.pred, mortes), names_to = "Tipo", values_to = "Mortes") |> 
  mutate(Tipo = if_else(Tipo == "mortes", 
                        "√ìbitos reais", "√ìbitos previstos")) |> 
  ggplot(aes(data, Mortes)) +
    geom_ribbon(aes(ymin = .pred_lower.80., ymax = .pred_upper.80.), fill = "grey80", alpha = 0.5) +
    geom_ribbon(aes(ymin = .pred_lower.95., ymax = .pred_upper.95.), fill = "grey90", alpha = 0.5) +
    geom_line(aes(color = Tipo)) +
    geom_point(aes(text = paste0(Tipo,": ", round(Mortes, 0)), color = Tipo), size = 0.5) +
    scale_color_manual(values = paleta) +
    labs(x = NULL, y = NULL) +
    scale_y_continuous(labels = comma_format(big.mark = ".", decimal.mark = ",")) +
    scale_x_date(date_breaks = "2 years")

ggplotly(plot_pre_ets, tooltip = "text")
```

## M√©tricas

```{r}
#| echo: false
#| tbl-cap: M√©tricas para ETS
#| label: tbl-metrics-ets

metricas_ets |> 
  select(-.estimator) |> 
  mutate(
    .metric = case_match(
      .metric,
      "rmse" ~ "RMSE",
      "mae" ~ "MAE",
      "rsq" ~ "R¬≤"
    )
  ) |> 
  rename(M√©trica = .metric, Valor = .estimate) |> 
  mutate(Valor = format(Valor, decimal.mark = ",", digits = 2)) |> 
  kable(
    align = c("l","r"), 
    table.attr = "quarto-disable-processing=true"
  ) |> 
  kable_styling(full_width = F) |> 
  column_spec(1, width = "6cm", bold = T)
```
:::

Modelos de suaviza√ß√£o s√£o ainda mais simplistas que modelos ARIMA j√° que constituem m√©todos de filtragem espectral convencionais. Usualmente, a literatura destaca que modelos autoregressivos s√£o mais adequados para s√©ries temporais ruidosas, enquanto modelos exponenciais respondem melhor √† s√©ries sazonais. Outra poss√≠vel vantagem da exponencia√ß√£o √© sua prioriza√ß√£o de dados mais novos, dado que este m√©todo reduz o peso de cada observa√ß√£o exponencialmente conforme a dist√¢ncia do valor mais recente [@shumway2017].

### Compara√ß√£o de Modelos

Ap√≥s os experimentos, a sele√ß√£o de um modelo final √© feita de forma comparativa, considerando n√£o apenas os √≠ndices de m√©tricas de erros calculados mas tamb√©m as caracter√≠sticas e capacidades de cada modelo individualmente. A @tbl-compare demonstra os valores de desempenho dos modelos:

```{r}
#| echo: false
#| tbl-cap: Compara√ß√£o de m√©tricas para todos os modelos
#| label: tbl-compare

rbind(
  mutate(metricas_anual, modelo = "Regress√£o Linear", resol = "Anual"),
  mutate(metricas_trimestre, modelo = "Regress√£o Linear", resol = "Trimestral"),
  mutate(metricas_mensal, modelo = "Regress√£o Linear", resol = "Mensal"),
  mutate(metricas_rf, modelo = "Random Forest Regressor", resol = "Mensal"),
  mutate(metricas_ets, modelo = "Exponential Smoothing", resol = "Mensal"),
  mutate(metricas_sarima, modelo = "SARIMA", resol = "Mensal")
) |>
  select(-.estimator) |>
  pivot_wider(names_from = .metric, values_from = .estimate) |>
  rename_with(toupper, rmse:rsq) |>
  group_by(resol) |>
  gt(rowname_col = "model") |>
  cols_label(modelo = "Modelo") |>
  fmt_number(decimals = 2,
             sep_mark = ".",
             dec_mark = ",") |>
  tab_options(
    column_labels.background.color = onsv_palette$blue,
    column_labels.font.weight = "bold"
  ) |>
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title())
```

RMSE e MAE melhoram em resolu√ß√µes menores de unidades de tempo, sendo consequ√™ncia indireta da maior disponibilidade de dados para o treinamento do modelo. Mesmo assim, ser√° percept√≠vel que, por exemplo, um modelo mensal bem ajustado n√£o prev√™ um ano inteiro melhor que um modelo anual, por efeito da acumula√ß√£o de erros associados √†s previs√µes de cada m√™s. Como implica a @tbl-compare, o modelo linear anual aparenta ter resultados mais plaus√≠veis que o mensal, mesmo tendo um desempenho de RMSE e MAE inferior. Em rela√ß√£o ao RSQ, o modelo anual apresenta o melhor desempenho.

```{r}
#| include: false

pred_list <- list(
  rename(
    pred_anual_2023, 
    pred.anual = .pred, 
    upper.anual = .pred_upper, 
    lower.anual = .pred_lower
  ),
  summarise(
    mutate(pred_trimestre_2023, ano = year(data)),
    .by = ano,
    pred.trimestral = sum(.pred),
    upper.trimestral = sum(.pred_upper),
    lower.trimestral = sum(.pred_lower)
  ),
  summarise(
    mutate(pred_mensal_2023, ano = year(data)),
    .by = ano,
    pred.mensal = sum(.pred),
    upper.mensal = sum(.pred_upper),
    lower.mensal = sum(.pred_lower)
  ),
  summarise(
    mutate(rf_pred, ano = year(data)),
    .by = ano,
    pred.rf = sum(.pred)
  ),
  summarise(
    mutate(sarima_pred, ano = year(data)),
    .by = ano,
    pred.sarima = sum(.pred),
    upper.sarima = sum(.pred_upper.80.),
    lower.sarima = sum(.pred_lower.80.)
  ),
  summarise(
    mutate(ets_pred, ano = year(data)),
    .by = ano,
    pred.ets = sum(.pred),
    upper.ets = sum(.pred_upper.80.),
    lower.ets = sum(.pred_lower.80.)
  )
)
```

```{r}
#| echo: false
#| tbl-cap: Previs√µes de todos os modelos para 2023
#| label: tbl-preds

pred_list |> 
  reduce(left_join, by = "ano") |> 
  select(c(ano, starts_with(c("pred","upper","lower")))) |> 
  last() |> 
  pivot_longer(-ano) |> 
  mutate(
    modelo = str_remove(str_extract(name, "\\..*"), "\\."),
    tipo = str_remove(str_extract(name, "^(.*?)\\."), "\\.")
  ) |> 
  select(-c(ano, name)) |> 
  pivot_wider(values_from = value, names_from = tipo) |> 
  mutate(
    modelo = case_match(
      modelo,
      "anual" ~ "Linear Anual",
      "trimestral" ~ "Linear Trimestral",
      "mensal" ~ "Linear Mensal",
      "rf" ~ "RF Mensal",
      "sarima" ~ "SARIMA Mensal",
      "ets" ~ "ETS Mensal"
    )
  ) |> 
  gt() |> 
  cols_label(
    modelo = "Modelo",
    pred = "Previs√£o",
    upper = "M√°x.",
    lower = "M√≠n."
  ) |> 
  fmt_number(decimals = 0,
             sep_mark = ".",
             dec_mark = ",") |>
  tab_options(
    column_labels.background.color = onsv_palette$blue,
    column_labels.font.weight = "bold"
  ) |>
  tab_style(style = cell_text(color = onsv_palette$blue),
            locations = cells_title()) |> 
  sub_missing(missing_text = "-") |> 
  tab_footnote(
    footnote = "Algoritmo n√£o produz intervalo de confian√ßa",
    locations = cells_body(columns = modelo,
                           rows = modelo == "RF Mensal"),
    placement = "left"
  ) |> 
  opt_footnote_marks("standard")
```

Nota-se que ambos os m√©todos de an√°lise de s√©ries temporais prev√™em uma queda, enquanto os modelos regressivos estipulam que as fatalidades crescem. Na @fig-facet-pred, os resultados de cada modelo foram agrupados e somados por ano para visualiza√ß√£o de cada s√©rie temporal individualmente:

```{r}
#| echo: false
#| fig-cap: Gr√°ficos de previs√µes para 2023 
#| label: fig-facet-pred

dodge <- position_dodge(1)

plot_comparison <- pred_list |> 
  reduce(left_join, by = "ano") |> 
  select(c(ano, mortes, starts_with("pred"))) |> 
  pivot_longer(starts_with("pred"), names_to = "tipo", values_to = "pred") |>
  mutate(tipo = case_match(tipo,
                           "pred.anual" ~ "Linear Anual",
                           "pred.trimestral" ~ "Linear Trimestral",
                           "pred.mensal" ~ "Linear Mensal",
                           "pred.rf" ~ "RF Mensal",
                           "pred.sarima" ~ "SARIMA Mensal",
                           "pred.ets" ~ "ETS Mensal")) |> 
  ggplot(aes(ano, mortes)) +
    geom_line(aes(y = pred, color = "√ìbitos previstos")) +
    geom_point(aes(y = pred, color = "√ìbitos previstos", 
                   text = paste("Previstos:", round(pred)))) +
    geom_line(aes(color = "√ìbitos reais")) +
    geom_point(aes(color = "√ìbitos reais", 
                   text = paste("√ìbitos:", mortes))) +
    scale_color_manual(values = c(onsv_palette$blue, onsv_palette$yellow)) +
    scale_x_continuous(breaks = seq(2011, 2023, 1), limits = c(2011, NA)) +
    scale_y_continuous(labels = label_comma(decimal.mark = ",", big.mark = ".")) +
    theme(axis.text.x = element_text(angle = 90)) +
    facet_wrap(tipo ~ .) +
    labs(x = NULL, y = NULL)
    
ggplotly(plot_comparison, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```

```{r}
#| include: false

load(here("data/populacao.rda"))
```

Em quest√£o das taxas anteriormente discutidas para quantifica√ß√£o dos √≥bitos em rela√ß√£o √† popula√ß√£o e √† frota veicular, novos valores podem ser calculados sobre as previs√µes a fim de averiguar a mudan√ßa destas taxas em fun√ß√£o do tempo e tipo de modelo:

::: panel-tabset
## √ìbitos por 100 mil hab.

```{r}
#| echo: false
#| fig-cap: Previs√µes por 100 mil habitantes
#| label: fig-pred-hab

plot_taxa_popul <- pred_list |> 
  append(list(populacao)) |> 
  reduce(left_join, by = "ano") |> 
  select(c(ano, mortes, populacao, starts_with("pred"))) |> 
  pivot_longer(starts_with("pred"), names_to = "tipo", values_to = "pred") |> 
  mutate(taxa_pred = round((pred/populacao) * 100000, 2),
         taxa_real = round((mortes/populacao) * 100000, 2),
         tipo = case_match(tipo,
                           "pred.anual" ~ "Linear Anual",
                           "pred.trimestral" ~ "Linear Trimestral",
                           "pred.mensal" ~ "Linear Mensal",
                           "pred.rf" ~ "RF Mensal",
                           "pred.sarima" ~ "SARIMA Mensal",
                           "pred.ets" ~ "ETS Mensal")) |> 
  ggplot(aes(ano, taxa_real)) +
    geom_line(aes(y = taxa_pred, color = "√ìbitos previstos")) +
    geom_point(aes(y = taxa_pred, color = "√ìbitos previstos", 
                   text = paste("Taxa prevista:", taxa_pred))) +
    geom_line(aes(color = "√ìbitos reais")) +
    geom_point(aes(color = "√ìbitos reais", 
                   text = paste("Taxa real:", taxa_real))) +
    scale_color_manual(values = c(onsv_palette$blue, onsv_palette$yellow)) +
    scale_x_continuous(breaks = seq(2011, 2021, 1), limits = c(2011, 2021)) +
    theme(axis.text.x = element_text(angle = 90)) +
    facet_wrap(tipo ~ .) +
    labs(x = NULL, y = NULL)
  
ggplotly(plot_taxa_popul, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```

## √ìbitos por 10 mil veic.

```{r}
#| echo: false
#| fig-cap: Previs√µes por 10 mil ve√≠culos
#| label: fig-pred-veic

plot_taxa_frota <- pred_list |> 
  reduce(left_join, by = "ano") |> 
  select(c(ano, mortes, frota, starts_with("pred"))) |> 
  pivot_longer(starts_with("pred"), names_to = "tipo", values_to = "pred") |> 
  mutate(taxa_pred = round((pred/frota) * 10000, 2),
         taxa_real = round((mortes/frota) * 10000, 2),
         tipo = case_match(tipo,
                           "pred.anual" ~ "Linear Anual",
                           "pred.trimestral" ~ "Linear Trimestral",
                           "pred.mensal" ~ "Linear Mensal",
                           "pred.rf" ~ "RF Mensal",
                           "pred.sarima" ~ "SARIMA Mensal",
                           "pred.ets" ~ "ETS Mensal")) |> 
  ggplot(aes(ano, taxa_real)) +
    geom_line(aes(y = taxa_pred, color = "√ìbitos previstos")) +
    geom_point(aes(y = taxa_pred, color = "√ìbitos previstos", 
                   text = paste("Taxa prevista:", taxa_pred))) +
    geom_line(aes(color = "√ìbitos reais")) +
    geom_point(aes(color = "√ìbitos reais", 
                   text = paste("Taxa real:", taxa_real))) +
    scale_color_manual(values = c(onsv_palette$blue, onsv_palette$yellow)) +
    scale_x_continuous(breaks = seq(2011, 2021, 1), limits = c(2011, 2021)) +
    theme(axis.text.x = element_text(angle = 90)) +
    facet_wrap(tipo ~ .) +
    labs(x = NULL, y = NULL)

ggplotly(plot_taxa_frota, tooltip = "text") |> 
  layout(legend = list(title = list(text = "")))
```
:::

## Conclus√£o

Os modelos regressivos desenvolvidos antecipam uma tend√™ncia ao aumento relativo nas v√≠timas de sinistros de tr√¢nsito em 2023, uma revela√ß√£o preocupante √† presente situa√ß√£o da seguran√ßa vi√°ria no Brasil. Em contrapartida, os modelos de s√©ries tempoais prev√™em uma poss√≠vel diminui√ß√£o, provavelmente devido a sensibilidade destes tipos de t√©cnicas √† sazonalidade. Por isso, a an√°lise de regress√£o permanece como a abordagem mais interessante no contexto do fen√¥meno estudado, tanto pela qualidade da previs√£o quanto pela capacidade explicativa deste tipo de metodologia.

√â fundamental tamb√©m destacar que as solu√ß√µes de seguran√ßa vi√°ria n√£o dependem apenas de atributos da mobilidade urbana. In√∫meros fatores socioecon√¥micos e de infraestrutura podem afetar o desempenho da seguran√ßa. O cen√°rio atual da seguran√ßa vi√°ria brasileira apresenta alguns desafios e defici√™ncias que podem impactar na conquista das metas de redu√ß√£o estabelecidas em √¢mbito nacional pelo PNATRANS. Os dados previstos mostram um desempenho abaixo do ideal no combate da fatalidade no tr√¢nsito brasileiro, conferindo uma perspectiva pessimista para a d√©cada atual no Brasil e, caso este cen√°rio n√£o seja amenizado com anteced√™ncia, √© improv√°vel a ocorr√™ncia de avan√ßos significativos nos objetivos da Segunda D√©cada de A√ß√£o pela Seguran√ßa no Tr√¢nsito.

## Refer√™ncias
